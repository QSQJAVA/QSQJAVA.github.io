<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、算法分析前面我们已经介绍了，研究算法的最终目的就是如何花更少的时间，如何占用更少的内存去完成相同的需求，并且也通过案例演示了不同算法之间时间耗费和空间耗费上的差异，但我们并不能将时间占用和空间占用量化，因此，接下来我们要学习有关算法时间耗费和算法空间耗费的描述和分析。有关算法时间耗费分析，我们称之为算法的**时间复杂度分析，有关算法的空间耗费分析，我们称之为算法的空间复杂度分析**。">
<meta property="og:type" content="article">
<meta property="og:title" content="算法分析">
<meta property="og:url" content="http://example.com/2021/11/29/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="JAVA信徒">
<meta property="og:description" content="一、算法分析前面我们已经介绍了，研究算法的最终目的就是如何花更少的时间，如何占用更少的内存去完成相同的需求，并且也通过案例演示了不同算法之间时间耗费和空间耗费上的差异，但我们并不能将时间占用和空间占用量化，因此，接下来我们要学习有关算法时间耗费和算法空间耗费的描述和分析。有关算法时间耗费分析，我们称之为算法的**时间复杂度分析，有关算法的空间耗费分析，我们称之为算法的空间复杂度分析**。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122152538851.png">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122153126181.png">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122153213341.png">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122153509524.png">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122153726332.png">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122153942400.png">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122153950103.png">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122170848213.png">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122170858723.png">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122170928331.png">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122171246306.png">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122184356736.png">
<meta property="og:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122184421424.png">
<meta property="article:published_time" content="2021-11-29T10:31:25.038Z">
<meta property="article:modified_time" content="2021-11-29T10:31:13.210Z">
<meta property="article:author" content="尘埃星球">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122152538851.png">

<link rel="canonical" href="http://example.com/2021/11/29/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法分析 | JAVA信徒</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JAVA信徒</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录JAVA修仙过程</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">17</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/qsqjava/qsqjava.github.io" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/29/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="尘埃星球">
      <meta itemprop="description" content="时间会回答一切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JAVA信徒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-29 18:31:25 / 修改时间：18:31:13" itemprop="dateCreated datePublished" datetime="2021-11-29T18:31:25+08:00">2021-11-29</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一、算法分析"><a href="#一、算法分析" class="headerlink" title="一、算法分析"></a><strong>一、算法分析</strong></h1><p>前面我们已经介绍了，研究算法的最终目的就是如何花更少的时间，如何占用更少的内存去完成相同的需求，并且也通过案例演示了不同算法之间时间耗费和空间耗费上的差异，但我们并不能将时间占用和空间占用量化，因此，接下来我们要学习有关算法时间耗费和算法空间耗费的描述和分析。有关算法时间耗费分析，我们称之为算法的**<u>时间复杂度分析</u><strong>，有关算法的空间耗费分析，我们称之为算法的</strong><u>空间复杂度分析</u>**。</p>
<span id="more"></span>

<h2 id="1-1-算法的时间复杂度分析"><a href="#1-1-算法的时间复杂度分析" class="headerlink" title="1.1 算法的时间复杂度分析"></a><strong>1.1</strong> 算法的时间复杂度分析</h2><p>我们要计算算法时间耗费情况，首先我们得度量算法的执行时间，那么如何度量呢？</p>
<p>事后分析估算方法：</p>
<p>比较容易想到的方法就是我们把算法执行若干次，然后拿个计时器在旁边计时，这种事后统计的方法看上去的确不错，并且也并非要我们真的拿个计算器在旁边计算，因为计算机都提供了计时的功能。这种统计方法主要是通过设计好的测试程序和测试数据，利用计算机计时器对不同的算法编制的程序的运行时间进行比较，从而确定算法效率的高低，但是这种方法有很大的缺陷：必须依据算法实现编制好的测试程序，通常要花费大量时间和精力，测试完了如果发现测试的是非常糟糕的算法，那么之前所做的事情就全部白费了，并且不同的测试环境(硬件环境)的差别导致测试的结果差异也很大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="keyword">int</span> n=<span class="number">100</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; </span><br><span class="line">        sum += i; </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;sum=&quot;</span> + sum); </span><br><span class="line">    S</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis(); </span><br><span class="line">    System.out.println(end-start); &#125;</span><br></pre></td></tr></table></figure>

<p> 事前分析估算方法：</p>
<p>在计算机程序编写前，依据统计方法对算法进行估算，经过总结，我们发现一个高级语言编写的程序程序在计算机</p>
<p>上运行所消耗的时间取决于下列因素：</p>
<p> 1.算法采用的策略和方案；</p>
<p> 2.编译产生的代码质量；</p>
<p> 3.问题的输入规模(所谓的问题输入规模就是输入量的多少)；</p>
<p> 4.机器执行指令的速度；</p>
<p>由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。如果算法固定，那么该算法的执行时间就只和问题的输入规模有关系了。</p>
<p>我么再次以之前的求和案例为例，进行分析。</p>
<p><strong>需求：</strong></p>
<p>计算1到100的和。</p>
<p>第一种解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果输入量为n为<span class="number">1</span>，则需要计算<span class="number">1</span>次； </span><br><span class="line">如果输入量n为<span class="number">1</span>亿，则需要计算<span class="number">1</span>亿次； </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//执行1次 </span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//执行了n+1次 </span></span><br><span class="line">        sum += i;</span><br><span class="line">        <span class="comment">//执行了n次 </span></span><br><span class="line">    &#125;System.out.println(<span class="string">&quot;sum=&quot;</span> + sum); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果输入量为n为<span class="number">1</span>，则需要计算<span class="number">1</span>次； 如果输入量n为<span class="number">1</span>亿，则需要计算<span class="number">1</span>次； </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//执行1次 </span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次 </span></span><br><span class="line">    sum = (n+<span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//执行1次 </span></span><br><span class="line">    System.out.println(<span class="string">&quot;sum=&quot;</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，当输入规模为n时，第一种算法执行了1+1+(n+1)+n=2n+3次；第二种算法执行了1+1+1=3次。如果我们把第一种算法的循环体看做是一个整体，忽略结束条件的判断，那么其实这两个算法运行时间的差距就是n和1的差距。</p>
<p>为什么循环判断在算法1里执行了n+1次，看起来是个不小的数量，但是却可以忽略呢？我们来看下一个例子：</p>
<p><strong>需求：</strong></p>
<p>计算100个1+100个2+100个3+…100个100的结果</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">100</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n ; i++) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=n ; j++) &#123; </span><br><span class="line">            sum+=i; &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;sum=&quot;</span>+sum); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子中，如果我们要精确的研究循环的条件执行了多少次，是一件很麻烦的事情，并且，由于真正计算和的代码是内循环的循环体，所以，在研究算法的效率时，我们只考虑核心代码的执行次数，这样可以简化分析。</p>
<p>我们研究算法复杂度，侧重的是当输入规模不断增大时，算法的增长量的一个抽象(规律)，而不是精确地定位需要执行多少次，因为如果是这样的话，我们又得考虑回编译期优化等问题，容易主次跌倒。</p>
<p>我们不关心编写程序所用的语言是什么，也不关心这些程序将跑在什么样的计算机上，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止的条件、变量声明、打印结果等操作，最终在分析程序的运行时间时，最重要的是把程序看做是独立于程序设计语言的算法或一系列步骤。我们分析一个算法的运行时间，最重要的就是把核心操作的次数和输入规模关联起来。</p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122152538851.png" alt="image-20211122152538851"></p>
<h2 id="1-1-1-函数渐近增长"><a href="#1-1-1-函数渐近增长" class="headerlink" title="1.1.1 函数渐近增长"></a><strong>1.1.1</strong> <strong>函数渐近增长</strong></h2><p><strong>概念：</strong></p>
<p>给定两个函数f(n)和g(n),如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n)。概念似乎有点艰涩难懂，那接下来我们做几个测试。</p>
<p><strong>测试一：</strong></p>
<p>假设四个算法的输入规模都是n：</p>
<p> 1.算法A1要做2n+3次操作，可以这么理解：先执行n次循环，执行完毕后，再有一个n次循环，最后有3次运算；</p>
<p> 2.算法A2要做2n次操作；</p>
<p> 3.算法B1要做3n+1次操作，可以这个理解：先执行n次循环，再执行一个n次循环，再执行一个n次循环，最后有1次运算。</p>
<p> 4.算法B2要做3n次操作；那么，上述算法，哪一个更快一些呢？</p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122153126181.png"></p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122153213341.png" alt="image-20211122153213341"></p>
<p>通过数据表格，比较算法A1和算法B1：</p>
<p>当输入规模n=1时，A1需要执行5次，B1需要执行4次，所以A1的效率比B1的效率低；</p>
<p>当输入规模n=2时，A1需要执行7次，B1需要执行7次，所以A1的效率和B1的效率一样；</p>
<p>当输入规模n&gt;2时，A1需要的执行次数一直比B1需要执行的次数少，所以A1的效率比B1的效率高；</p>
<p>所以我们可以得出结论</p>
<p><strong>当输入规模n&gt;2时，算法A1的渐近增长小于算法B1的渐近增长</strong></p>
<p>通过观察折线图，我们发现，随着输入规模的增大，算法A1和算法A2逐渐重叠到一块，算法B1和算法B2逐渐重叠</p>
<p>到一块，所以我们得出结论：</p>
<p><strong>随着输入规模的增大，算法的常数操作可以忽略不计</strong></p>
<p><strong>测试二：</strong></p>
<p>假设四个算法的输入规模都是n：</p>
<p> 1.算法C1需要做4n+8次操作</p>
<p> 2.算法C2需要做n次操作</p>
<p> 3.算法D1需要做2n^2次操作</p>
<p> 4.算法D2需要做n^2次操作</p>
<p>那么上述算法，哪个更快一些？ </p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122153509524.png" alt="image-20211122153509524"></p>
<p>通过数据表格，对比算法C1和算法D1：</p>
<p>当输入规模n&lt;=3时，算法C1执行次数多于算法D1，因此算法C1效率低一些；</p>
<p>当输入规模n&gt;3时，算法C1执行次数少于算法D1，因此，算法D2效率低一些，</p>
<p>所以，总体上，算法C1要优于算法D1</p>
<p>通过折线图，对比对比算法C1和C2：</p>
<p>随着输入规模的增大，算法C1和算法C2几乎重叠</p>
<p>通过折线图，对比算法C系列和算法D系列：</p>
<p>随着输入规模的增大，即使去除n^2前面的常数因子，D系列的次数要远远高于C系列。</p>
<p>因此，可以得出结论：</p>
<p><strong>随着输入规模的增大，与最高次项相乘的常数可以忽略</strong></p>
<p><strong>测试三：</strong></p>
<p>假设四个算法的输入规模都是n：</p>
<p>算法E1:</p>
<p>2n^2+3n+1;</p>
<p>算法E2：</p>
<p>n^2</p>
<p>算法F1：</p>
<p>2n^3+3n+1</p>
<p>算法F2：</p>
<p>n^3</p>
<p>那么上述算法，哪个更快一些？</p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122153726332.png" alt="image-20211122153726332"></p>
<p>通过数据表格，对比算法E1和算法F1： </p>
<p>当n=1时，算法E1和算法F1的执行次数一样；</p>
<p>当n&gt;1时，算法E1的执行次数远远小于算法F1的执行次数；</p>
<p>所以算法E1总体上是由于算法F1的。</p>
<p>通过折线图我们会看到，算法F系列随着n的增长会变得特块，算法E系列随着n的增长相比较算法F来说，变得比较</p>
<p>慢，所以可以得出结论：</p>
<p><strong>最高次项的指数大的，随着n的增长，结果也会变得增长特别快</strong></p>
<p><strong>测试四：</strong></p>
<p>假设五个算法的输入规模都是n：</p>
<p>算法G：</p>
<p>n^3;</p>
<p>算法H:</p>
<p>n^2;</p>
<p>算法I：</p>
<p>n:</p>
<p>算法J：</p>
<p>logn</p>
<p>算法K:</p>
<p>1</p>
<p>那么上述算法，哪个效率更高呢？</p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122153942400.png" alt="image-20211122153942400"></p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122153950103.png" alt="image-20211122153950103"></p>
<p>通过观察数据表格和折线图，很容易可以得出结论：</p>
<p><strong>算法函数中n最高次幂越小，算法效率越高</strong></p>
<p>总上所述，在我们比较算法随着输入规模的增长量时，可以有以下规则：</p>
<p><strong>1.算法函数中的常数可以忽略；</strong></p>
<p><strong>2.算法函数中最高次幂的常数因子可以忽略；</strong></p>
<p><strong>3.算法函数中最高次幂越小，算法效率越高。</strong></p>
<h2 id="1-1-2-算法时间复杂度"><a href="#1-1-2-算法时间复杂度" class="headerlink" title="1.1.2 算法时间复杂度"></a><strong>1.1.2 算法时间复杂度</strong></h2><h4 id="1-1-2-1-大O记法"><a href="#1-1-2-1-大O记法" class="headerlink" title="1.1.2.1 大O记法"></a><strong>1.1.2.1 大O记法</strong></h4><p><strong>定义：</strong></p>
<p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的量级。算法的时间复杂度，就是算法的时间量度，记作:T(n)=O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。</p>
<p>在这里，我们需要明确一个事情：<strong>执行次数=执行时间</strong></p>
<p>用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。</p>
<p>下面我们使用大O表示法来表示一些求和算法的时间复杂度：</p>
<p>算法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//执行1次 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次 </span></span><br><span class="line"></span><br><span class="line">sum = (n+<span class="number">1</span>)*n/<span class="number">2</span>;<span class="comment">//执行1次 </span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;sum=&quot;</span>+sum); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//执行1次 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; </span><br><span class="line"></span><br><span class="line">sum += i;<span class="comment">//执行了n次 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;sum=&quot;</span> + sum); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法三：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//执行1次 </span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n ; i++) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=n ; j++) &#123; </span><br><span class="line">sum+=i;<span class="comment">//执行n^2次 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;sum=&quot;</span>+sum); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果忽略判断条件的执行次数和输出语句的执行次数，那么当输入规模为n时，以上算法执行的次数分别为：</p>
<p>算法一：3次</p>
<p>算法二：n+3次</p>
<p>算法三：n^2+2次</p>
<p>如果用大O记法表示上述每个算法的时间复杂度，应该如何表示呢？基于我们对函数渐近增长的分析，推导大O阶</p>
<p>的表示法有以下几个规则可以使用：</p>
<p>*<em>1.<strong><strong>用常数</strong></strong>1</em>*<strong>取代运行时间中的所有加法常数；</strong></p>
<p>**2.**<strong>在修改后的运行次数中，只保留高阶项；</strong></p>
<p>*<em>3.<strong><strong>如果最高阶项存在，且常数因子不为</strong></strong>1</em>*<strong>，则去除与这个项相乘的常数；</strong></p>
<p>所以，上述算法的大O记法分别为：</p>
<p>算法一：O(1)</p>
<p>算法二：O(n)</p>
<p>算法三：O(n^2)</p>
<h4 id="1-1-2-2-常见的大O阶"><a href="#1-1-2-2-常见的大O阶" class="headerlink" title="1.1.2.2 常见的大O阶"></a><strong>1.1.2.2 常见的大O阶</strong></h4><p><strong>1.线性阶</strong></p>
<p>一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如：</p>
<p>上面这段代码，它的循环的时间复杂度为O(n),因为循环体中的代码需要执行n次</p>
<p><strong>2.平方阶</strong></p>
<p>一般嵌套循环属于这种时间复杂度</p>
<p>上面这段代码，n=100，也就是说，外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环</p>
<p>中出来，就需要执行100*100次，也就是n的平方次，所以这段代码的时间复杂度是O(n^2).</p>
<p><strong>3.立方阶</strong></p>
<p>一般三层嵌套循环属于这种时间复杂度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,n=<span class="number">100</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n ; i++) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;=n ; j++) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;=n ; j++) &#123; </span><br><span class="line">x++; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(x); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>上面这段代码，n=100，也就是说，外层循环每执行一次，中间循环循环就执行100次，中间循环每执行一次，最</p>
<p>内层循环需要执行100次，那总共程序想要从这三个循环中出来，就需要执行100<em>100</em>100次，也就是n的立方，所</p>
<p>以这段代码的时间复杂度是O(n^3).</p>
<p><strong>4.对数阶</strong></p>
<p>对数，属于高中数学的内容，我们分析程序以程序为主，数学为辅，所以不用过分担心。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>,n=<span class="number">100</span>; </span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123; </span><br><span class="line">i = i*<span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。由于是2^x=n,得到x=log(2)n,所</p>
<p>以这个循环的时间复杂度为O(logn);</p>
<p>对于对数阶，由于随着输入规模n的增大，不管底数为多少，他们的增长趋势是一样的，所以我们会忽略底数。</p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122170848213.png" alt="image-20211122170848213"></p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122170858723.png" alt="image-20211122170858723"></p>
<p><strong>5.常数阶</strong></p>
<p>一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增加操作次数。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">100</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=n+<span class="number">2</span>; </span><br><span class="line"></span><br><span class="line">System.out.println(i); </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>上述代码，不管输入规模n是多少，都执行2次，根据大O推导法则，常数用1来替换，所以上述代码的时间复杂度</p>
<p>为O(1)</p>
<p>下面是对常见时间复杂度的一个总结：</p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122170928331.png" alt="image-20211122170928331"></p>
<p>他们的复杂程度从低到高依次为：</p>
<p> O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)</p>
<p>根据前面的折线图分析，我们会发现，从平方阶开始，随着输入规模的增大，时间成本会急剧增大，所以，我们的算法，尽可能的追求的是O(1),O(logn),O(n),O(nlogn)这几种时间复杂度，而如果发现算法的时间复杂度为平方阶、立方阶或者更复杂的，那我们可以分为这种算法是不可取的，需要优化。</p>
<h4 id="1-1-2-3-函数调用的时间复杂度分析"><a href="#1-1-2-3-函数调用的时间复杂度分析" class="headerlink" title="1.1.2.3 函数调用的时间复杂度分析"></a><strong>1.1.2.3</strong> <strong>函数调用的时间复杂度分析</strong></h4><p>之前，我们分析的都是单个函数内，算法代码的时间复杂度，接下来我们分析函数调用过程中时间复杂度。</p>
<p><strong>案例一：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> n=<span class="number">100</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">show(i); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line">System.out.println(i); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部只执行了一行代码，所以show方法</p>
<p>的时间复杂度为O(1),那main方法的时间复杂度就是O(n)</p>
<p><strong>案例二：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> n=<span class="number">100</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">show(i); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; i++) &#123; </span><br><span class="line">System.out.println(i); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部也有一个for循环，所以show方法</p>
<p>的时间复杂度为O(n),那main方法的时间复杂度为O(n^2)</p>
<p><strong>案例三：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">100</span>; </span><br><span class="line"></span><br><span class="line">show(n); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line"></span><br><span class="line">show(i); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(j); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; i++) &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(i); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在show方法中，有一个for循环，所以show方法的时间复杂度为O(n),在main方法中，show(n)这行代码内部执行的次数为n，第一个for循环内调用了show方法，所以其执行次数为n^2,第二个嵌套for循环内只执行了一行代码，所以其执行次数为n^2,那么main方法总执行次数为n+n^2+n^2=2n^2+n。根据大O推导规则，去掉n保留最高阶项，并去掉最高阶项的常数因子2，所以最终main方法的时间复杂度为O(n^2)</p>
<h4 id="1-1-2-4-最坏情况"><a href="#1-1-2-4-最坏情况" class="headerlink" title="1.1.2.4 最坏情况"></a><strong>1.1.2.4</strong> <strong>最坏情况</strong></h4><p>从心理学角度讲，每个人对发生的事情都会有一个预期，比如看到半杯水，有人会说：哇哦，还有半杯水哦！但也有人会说：天哪，只有半杯水了。一般人处于一种对未来失败的担忧，而在预期的时候趋向做最坏的打算，这样即使最糟糕的结果出现，当事人也有了心理准备，比较容易接受结果。假如最糟糕的结果并没有出现，当事人会很快乐。</p>
<p>算法分析也是类似，假如有一个需求：</p>
<p>有一个存储了n个随机数字的数组，请从中查找出指定的数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">0</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num==arr[i])&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>最好情况：</strong></p>
<p>查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1)</p>
<p><strong>最坏情况：</strong></p>
<p>查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n)</p>
<p><strong>平均情况：</strong></p>
<p>任何数字查找的平均成本是O(n/2)最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非特别指定，我们提到的运行时间都指的是最坏情况下的运行时间。</p>
<h2 id="1-2-算法的空间复杂度分析"><a href="#1-2-算法的空间复杂度分析" class="headerlink" title="1.2 算法的空间复杂度分析"></a><strong>1.2</strong> <strong>算法的空间复杂度分析</strong></h2><p>计算机的软硬件都经历了一个比较漫长的演变史，作为为运算提供环境的内存，更是如此，从早些时候的512k,经历了1M，2M，4M…等，发展到现在的8G，甚至16G和32G，所以早期，算法在运行过程中对内存的占用情况也是一个经常需要考虑的问题。我么可以用算法的空间复杂度来描述算法对内存的占用。</p>
<h3 id="1-2-1-java中常见内存占用"><a href="#1-2-1-java中常见内存占用" class="headerlink" title="1.2.1 java中常见内存占用"></a><strong>1.2.1 java中常见内存占用</strong></h3><p>1.基本数据类型内存占用情况</p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122171246306.png" alt="image-20211122171246306"></p>
<p>2.计算机访问内存的方式都是一次一个字节</p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122184356736.png" alt="image-20211122184356736"></p>
<p>3.一个引用（机器地址）需要8个字节表示：</p>
<p>例如： Date date = new Date(),则date这个变量需要占用8个字节来表示</p>
<p>4.创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。</p>
<p>5.一般内存的使用，如果不够8个字节，都会被自动填充为8字节：</p>
<p><img src="https://1499842252.oss-cn-beijing.aliyuncs.com/image/markdown/image-20211122184421424.png" alt="image-20211122184421424"></p>
<p>6.java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要24字节的头信息(16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。</p>
<h3 id="1-2-2-算法的空间复杂度"><a href="#1-2-2-算法的空间复杂度" class="headerlink" title="1.2.2 算法的空间复杂度"></a><strong>1.2.2</strong> <strong>算法的空间复杂度</strong></h3><p>了解了java的内存最基本的机制，就能够有效帮助我们估计大量程序的内存使用情况。</p>
<p>算法的空间复杂度计算公式记作：S(n)=O(f(n)),其中n为输入规模，f(n)为语句关于n所占存储空间的函数。</p>
<p><strong>案例：</strong></p>
<p>对指定的数组元素进行反转，并返回反转的内容。</p>
<p>解法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse1(<span class="keyword">int</span>[] arr)&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n=arr.length;<span class="comment">//申请4个字节 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;<span class="comment">//申请4个字节 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>,end=n-<span class="number">1</span>;start&lt;=end;start++,end--)&#123; </span><br><span class="line"></span><br><span class="line">temp=arr[start]; </span><br><span class="line"></span><br><span class="line">arr[start]=arr[end]; </span><br><span class="line"></span><br><span class="line">arr[end]=temp; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arr; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse2(<span class="keyword">int</span>[] arr)&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n=arr.length;<span class="comment">//申请4个字节 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] temp=<span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//申请n*4个字节+数组自身头信息开销24个字节 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123; </span><br><span class="line"></span><br><span class="line">temp[n-<span class="number">1</span>-i]=arr[i]; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>忽略判断条件占用的内存，我们得出的内存占用情况如下：</p>
<p>算法一：</p>
<p>不管传入的数组大小为多少，始终额外申请4+4=8个字节；</p>
<p>算法二：</p>
<p>4+4n+24=4n+28;</p>
<p>根据大O推导法则，算法一的空间复杂度为O(1),算法二的空间复杂度为O(n),所以从空间占用的角度讲，算法一要</p>
<p>优于算法二。</p>
<p>由于java中有内存垃圾回收机制，并且jvm对程序的内存占用也有优化（例如即时编译），我们无法精确的评估一个java程序的内存占用情况，但是了解了java的基本内存占用，使我们可以对java程序的内存占用情况进行估算。</p>
<p>由于现在的计算机设备内存一般都比较大，基本上个人计算机都是4G起步，大的可以达到32G，所以内存占用一般情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。</p>
<p>但是，如果你做的程序是嵌入式开发，尤其是一些传感器设备上的内置程序，由于这些设备的内存很小，一般为几kb，这个时候对算法的空间复杂度就有要求了，但是一般做java开发的，基本上都是服务器开发，一般不存在这样的问题。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构与算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/" rel="prev" title="数据结构和算法概述">
      <i class="fa fa-chevron-left"></i> 数据结构和算法概述
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">


      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>



      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">一、算法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 算法的时间复杂度分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-1-%E5%87%BD%E6%95%B0%E6%B8%90%E8%BF%91%E5%A2%9E%E9%95%BF"><span class="nav-number">1.2.</span> <span class="nav-text">1.1.1 函数渐近增长</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-2-%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.3.</span> <span class="nav-text">1.1.2 算法时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-1-%E5%A4%A7O%E8%AE%B0%E6%B3%95"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">1.1.2.1 大O记法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%A4%A7O%E9%98%B6"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">1.1.2.2 常见的大O阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-3-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">1.1.2.3 函数调用的时间复杂度分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-4-%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5"><span class="nav-number">1.3.0.4.</span> <span class="nav-text">1.1.2.4 最坏情况</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">1.4.</span> <span class="nav-text">1.2 算法的空间复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-java%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.2.1 java中常见内存占用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.2.2 算法的空间复杂度</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1396141677&auto=1&height=66"></iframe>
      
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="尘埃星球"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">尘埃星球</p>
  <div class="site-description" itemprop="description">时间会回答一切</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/qsqjava/qsqjava.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qsqjava&#x2F;qsqjava.github.io" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1499842252@qq.com" title="E-Mail → mailto:1499842252@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">尘埃星球</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">123k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:51</span>
</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,255,0' opacity='1' zIndex='-1' count='250' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":250,"height":500},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
